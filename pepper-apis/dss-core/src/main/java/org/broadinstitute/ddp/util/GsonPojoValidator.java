package org.broadinstitute.ddp.util;

import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;
import javax.validation.ConstraintViolation;
import javax.validation.ElementKind;
import javax.validation.Path;
import javax.validation.Validation;
import javax.validation.Validator;
import javax.validation.ValidatorFactory;

import com.google.gson.annotations.SerializedName;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.StringUtils;

/**
 * Will use Hibernate Validator on a POJO that contains data that has been unmarshalled using GSON.
 * Generates errors that contain references to the JSON property names that would have been part of the JSON generated by GSON.
 *
 * <p>Important considerations:
 * - GSON only serializes/deserializes values in fields (i.e, it does not allow you to serialize
 *   bean property setters/getters or any methods
 * - Hibernate validator, on the other hand can be used to annotate bean properties and methods
 * - So: we will find any and all validation errors in the POJO based on the annotations associated with it.
 * - But reporting the path to the error only works when the Validation annotation is associated with an object
 *   field that get serialized by GSON
 */
@Slf4j
public class GsonPojoValidator {
    //docs claim validator is thread-safe. Let's share it then
    private static Validator VALIDATOR = null;

    private static Validator getValidator() {
        if (VALIDATOR == null) {
            ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
            VALIDATOR = factory.getValidator();
        }
        return VALIDATOR;
    }

    /**
     * Checks if object violates constraints, throws any errors.
     */
    public List<JsonValidationError> validateAsJson(Object gsonPojo) {
        List<JsonValidationError> jsonErrors = new ArrayList<>();
        Set<ConstraintViolation<Object>> pojoErrors = getValidator().validate(gsonPojo);
        for (ConstraintViolation<Object> pojoError : pojoErrors) {
            Path pojoPath = pojoError.getPropertyPath();
            List<String> jsonPath = inferJsonPath(pojoPath, gsonPojo);
            jsonErrors.add(new JsonValidationError(jsonPath, pojoError.getMessage(),
                    jsonPath == null ? null : pojoError.getInvalidValue()));
        }
        return jsonErrors;
    }

    /**
     * We have a path for a validation error in an object that was unmarshalled from JSON using GSON.
     * We are going to try to figure out what the path would be for the JSON object that would be generated
     * by GSON on the POJO
     *
     * @param gsonPojoPath the path to the validation error
     * @param gsonPojo     the pojo with the validation error
     * @return a list where each segment is either a JSON property name or a JSON property with an index
     *      If all goes well, the returned path will allow you to descend down the corresponding
     *      JSON object to the location of the validation error.
     *      Returns {@code null} if we cannot reach the location cleanly
     */
    public List<String> inferJsonPath(Path gsonPojoPath, Object gsonPojo) {
        Iterator<Path.Node> iter = gsonPojoPath.iterator();
        List<String> jsonPath = new ArrayList<>();
        Object currentGraphNode = gsonPojo;
        while (iter.hasNext()) {
            Path.Node currentPathNode = iter.next();
            //This is the only kind of node that we should have to deal with
            if (currentPathNode.getKind() == ElementKind.PROPERTY) {
                //Case where the path points to a collection-like thing
                if (currentPathNode.isInIterable()) {
                    String indexToken = null;
                    //It's a collection that is indexable
                    if (currentGraphNode instanceof Collection && currentPathNode.getIndex() != null) {
                        //We are treating like a List one way or the other
                        List<?> coll = (currentGraphNode instanceof List)
                                ? (List<?>) currentGraphNode : new ArrayList((Collection<?>) currentGraphNode);
                        currentGraphNode = coll.get(currentPathNode.getIndex());
                        indexToken = "[" + currentPathNode.getIndex() + "]";
                    }
                    //A collection without an index. Maybe a set?
                    if (currentGraphNode instanceof Collection && currentPathNode.getIndex() == null
                            && currentPathNode.getKey() == null) {
                        //We don't know which instance of the collection we are talking about. Let's iterate and find
                        // one that has a field that has the name we have and hope for the best
                        Optional<Object> foundObject = ((Collection<Object>) currentGraphNode).stream().filter(each -> {
                            try {
                                return each.getClass().getDeclaredField(currentPathNode.getName()) != null;
                            } catch (NoSuchFieldException e) {
                                return false; //Could not find it. Move on to next one
                            }
                        }).findFirst();
                        if (foundObject.isPresent()) {
                            indexToken = "[]";
                            currentGraphNode = foundObject.get();
                        } else {
                            //we reached the end of the line!
                            return null;
                        }

                        //it's an array!
                    } else if (currentGraphNode.getClass().isArray() && currentPathNode.getIndex() != null) {
                        currentGraphNode = ((Object[]) currentGraphNode)[currentPathNode.getIndex()];
                        indexToken = "[" + currentPathNode.getIndex() + "]";

                        //it's a map!
                    } else if (currentGraphNode instanceof Map && currentPathNode.getKey() != null) {
                        currentGraphNode = ((Map) currentGraphNode).get(currentPathNode.getKey());
                        indexToken = "[" + currentPathNode.getKey() + "]";
                    }

                    //It could be that the top-level object in graph is the collection-like thing
                    if (indexToken != null) {
                        if (jsonPath.isEmpty()) {
                            jsonPath.add(indexToken);
                        } else {
                            //If the collection was a child, then the index token can be added to it's path segment
                            int segmentLastIndex = jsonPath.size() - 1;
                            String updatedSegment = jsonPath.get(segmentLastIndex) + indexToken;
                            jsonPath.set(segmentLastIndex, updatedSegment);
                        }
                    }
                }
                Field currentField;
                try {
                    //Get a hold of the field. This is what we are here for!
                    currentField = getDeclaredFieldFromObjectHierarchy(currentGraphNode.getClass(), currentPathNode.getName());
                } catch (NoSuchFieldException e) {
                    //If you got here, you probably annotated with Validation constraint
                    // something that was not a field (e.g. a method)
                    jsonPath.add(currentPathNode.getName());
                    log.warn("Could not reach path in object graph where validation error was reported. Got as far as: "
                            + StringUtils.join(jsonPath.toArray(new String[0])), e);
                    return null;
                }

                //Is this a GSON annotated field?
                SerializedName serializedName = currentField.getAnnotation(SerializedName.class);

                //If uses annotation, then use the name that the field was changed to
                //otherwise the name will be the name of the field
                String jsonSegment = serializedName == null ? currentPathNode.getName() : serializedName.value();

                //add the segment to the path
                jsonPath.add(jsonSegment);

                boolean madeFieldAccessible = false;
                try {

                    if (!currentField.isAccessible()) {
                        //field is not public? we can fix that
                        currentField.setAccessible(true);
                        madeFieldAccessible = true;
                    }
                    //Update the current node and get ready to go deeper!
                    currentGraphNode = currentField.get(currentGraphNode);
                } catch (IllegalAccessException e) {
                    log.error("There was a problem navigating object graph", e);
                    return null;
                } finally {
                    //restore change we made to access
                    if (madeFieldAccessible) {
                        currentField.setAccessible(false);
                    }
                }
            } else {
                log.error("Could not traverse validation path provided because it included a segment of kind {} in "
                        + "path {}", currentPathNode.getKind(), gsonPojoPath);
                return null;
            }
        }

        return jsonPath;
    }

    public static String createValidationErrorMessage(List<JsonValidationError> errors, String delimiter) {
        if (delimiter == null) {
            delimiter = ", ";
        }
        return errors.stream()
                .map(JsonValidationError::toDisplayMessage)
                .collect(Collectors.joining(delimiter));
    }

    protected Field getDeclaredFieldFromObjectHierarchy(Class<?> theClass, String fieldName) throws NoSuchFieldException {
        try {
            return theClass.getDeclaredField(fieldName);
        } catch (NoSuchFieldException e) {
            Class<?> superClass = theClass.getSuperclass();
            if (superClass != null) {
                return getDeclaredFieldFromObjectHierarchy(superClass, fieldName);
            } else {
                throw new NoSuchFieldException("Could not find field in hierarchy with name: " + fieldName);
            }
        }
    }
}
